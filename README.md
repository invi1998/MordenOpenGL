# README

在开始这段旅程之前我们先了解一下OpenGL到底是什么。一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由[Khronos组织](http://www.khronos.org/)制定并维护的规范(Specification)。



本系列基本包含了什么是OpenGL，如何使用，它能为我们带来什么。第一次听说OpenGL但是并不清楚他到底是什么的时候，你可能会将其和图像联系起来，而那确实是OpenGL的功能，OpenGL是一个图形API，而API代表着用户图形接口（Application Program Interface），通俗的讲，它基本上是一堆函数，我们可以通过调用这些函数做某些事情。在这种情况下，OpenGL是一个图形API，它允许我们做些图像相关的事情。特别值得一提的是，OpenGL实际上还允许我们访问GPU（显卡），显卡可以更有力的绘制图形。实际上为了在电脑和其他设备（像手机）上使用显卡，我们需要一些API来操控显卡，而OpenGL就是这类众多API中的一个。我们也有其他这方面的API像是Direct3D（windows专用），Vulkan（最新一代OpenGL，语法方面和OpenGL差异较大）、Metal （苹果专用）和一些其他的。



OpenGL允许我们一定程度上操控我们的显卡，现在让我们澄清一些人对OpenGL的误解。首先，很多人称“OpenGL”为 库 或者 引擎 或者 框架，但其实这些都不是对的，OpenGL的核心是一种规范，类似于C++规范。实际上它并没有确定任何的代码或者类似的事情，它本身只是一个规范。说 hey，这个函数应该存在，他需要这个函数，并且需要返回这个值，他只是告诉你可以利用这些API做什么的规范，而不提供任何实现，这就意味着他不是一个库，因为它本身是没有任何代码的。



那么问题来了，我们去哪下载OpenGL呢？这的确是困扰很多新人的问题。实际上你并不需要下载任何东西，因为它本身是个规范，那这个规范谁去实现它呢？谁去为那些你会使用的OpenGL函数写代码呢？答案是你的显卡生产产商。如果你使用的是NVIDIA的显卡，那么你的显卡驱动程序就会包含OpenGL的实现。并且所有的显卡产商，像是AMD，Intel等，他们都会有自己的实现。当然，NVIDIA不会开个会和AMD说：”我们应该这样写我们的代码！“，所以每个显卡产商对OpenGL的实现都会有轻微的不同，所以这就是为什么在很多情况下，有些代码在基于NVIDIA显卡的驱动程序上能正常工作，但是在AMD或者其他显卡上显得有些不同，甚至产生BUG。但是无论怎么说，关键在于你的显卡产商是如何编写OpenGL实现的。



而这又可能引起另一个误解：OpenGL是开源的。导致这个误解的原因就是它的名字里有一个“Open”，但它并不是开源的，你是看不到他的源码的。首先，他是由显卡产商实现的，他们显然不会将显卡的驱动程序源码开源，有些人会写一些开源的OpenGL实现，如果我造了一个显卡，并且我想要支持OpenGL，那我就需要写一个驱动程序，那我可能会选择将代码开源在GitHub。但是在我们电脑上运行的显卡，比如NVIDIA或者AMD，你是没办法看到他们背后的OpenGL的源码的。所以OpenGL不可能是开源的，第一它只是规范，没有代码；第二我们现在使用的OpenGL也很可能不会是开源的。



那么倒底OpenGL提供了什么，让很多人高呼 “OpenGL天下第一”？可能就是因为它是跨平台的，所以你可以写一份OpenGL代码就可以在Windows，Mac（苹果电脑），Linux，ios，安卓系统上运行。那这个时候，可能有人就会说，那OpenGL岂不是比Direct3D牛？因为它能在所有平台上运行。但其实并不是这样的。因为OpenGL是跨平台的API，通常在游戏引擎中，并不会只涉及到一种图形API，特别是如果游戏引擎是跨平台的，那就意味着它们不能仅仅为了XBox或者其他一些平台做出实现，游戏引擎不得不实现很多图形API，事实上为某一个平台专门编写的API，像Direct3D就是专门为Windows编写的图形API，在Window上的表现一般比跨平台的API要好。但是总而言之，关于“API哪家强”的争论是没有意义的，因为平台原生的往往会更好一些。这也就是说，OpenGL像是一个确切的规范，他很普通，如果你把它和低层次的，像是DirectX12或者Vulkan比较的话，如果根据复杂度来说的话，有一些像是Metal, Metal比OpenGL要底层但是比Vulkan高级一些，OpenGL可能确实是初学者能学到的最简单的API了，所以OpenGL绝对值得学习。另一些跨平台API，比如Vulkan依然很新，并且很底层，比如一些Vulkan程序如果编写不成熟，它很可能因为一些BUG导致机器崩溃重启等。



---

# MordenOpenGL



老OpenGL和现代OpenGL有哪些区别呢？



首先之所以有这些区别的原因在于OpenGL是再90年代发布的，那时的情况和现在是大不相同的，那时的GPU并不是灵活且可编程的，你并不能随心所欲的操控它，尤其是哪些比较底层的API，比如老式的OpenGL不能着色，也就是说不能计算光照这类着色在模型上，而只能计算模型本身，但是现在，程序员们可以很大程度上控制它，或者说显卡产商给了程序员和开发者更多的控制权，这显然是很好的，我们可以进一步去优化显卡的使用。现在的OpenGL更强大，能让你比之前更好的控制GPU。



假设你绘制一个三角形面片，这时你想加入光源，那么你要怎么加入这个光源呢？你可以告诉OpenGL，类似“Lighting = true"的代码，这样你就能启用光源，然后你告诉OpenGL想要再这里加入关照，那你就得告诉OpenGL光源的位置等等....像这样的就叫做流水线式的操作，这种老式的OpenGL很容易被使用，代码也很少，但是与之对应的，程序员也没有多少控制权。



我们想要更多的控制权，实现更多令人惊叹的图形，通过shader向显卡发送对每个顶点或者每个像素的操作。所以老OpenGL和现代OpenGL的最大区别在于 shader（着色器）。对计算机图形学感兴趣的可能听说过 shader （着色器）这个词，shader是一段运行在GPU上的程序。所以我们用C++或者Java或者C#或者其他编程语言写的程序都是运行在CPU上的，但是当我们针对图形处理的时候，我们想要精确控制GPU，所以我们需要将一些代码从CPU上放到GPU上，因为他们在GPU上可以运行得更快，这就是shader的存在意义，shader允许我们在GPU上写程序。这也是这个系列想要做的事情，因为如果我们想要计算出复杂的关照算法，你一定会想要在GPU上计算而不是向过去一样在CPU上解决。**所以现代OpenGL和老OpenGL的最大区别在于是否有可编程的着色器**，当然也有其他的区别，后面会说到。



这个系列里将会讲述2D图形，快速2D图形，批处理，以及编写一个非常快速的2D渲染器，同时也会介绍3D的方方面面，比如光照和阴影，延迟着色，PBR物理渲染，老旧的延迟处理技术比如Bloom，体积雾的渲染，屏幕空间反射，基本上所有的事情都会做一遍。



## 核心模式与立即渲染模式

早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。



当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL**实际**运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。



这也是为什么我们的教程面向OpenGL3.3的核心模式。虽然上手更困难，但这份努力是值得的。

现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。

