## 词汇表

- **OpenGL**： 一个定义了函数布局和输出的图形API的正式规范。

- **GLAD**： 一个扩展加载库，用来为我们加载并设定所有OpenGL函数指针，从而让我们能够使用所有（现代）OpenGL函数。

- **视口(Viewport)**： 我们需要渲染的窗口。

- **图形管线(Graphics Pipeline)**： 一个顶点在呈现为像素之前经过的全部过程。

- **着色器(Shader)**： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。

- **标准化设备坐标(Normalized Device Coordinates, NDC)**： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见。

- **顶点缓冲对象(Vertex Buffer Object)**： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。

- **顶点数组对象(Vertex Array Object)**： 存储缓冲区和顶点属性状态。

- **元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)**： 一个存储元素索引供索引化绘制使用的缓冲对象。

- **Uniform**： 一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次。

- **纹理(Texture)**： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。

- **纹理环绕(Texture Wrapping)**： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式。

- **纹理过滤(Texture Filtering)**： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生。

- **多级渐远纹理(Mipmaps)**： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。

- **stb_image.h**： 图像加载库。

- **纹理单元(Texture Units)**： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。

- **向量(Vector)**： 一个定义了在空间中方向和/或位置的数学实体。

- **矩阵(Matrix)**： 一个矩形阵列的数学表达式。

- **GLM**： 一个为OpenGL打造的数学库。

- **局部空间(Local Space)**： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。

- **世界空间(World Space)**： 所有的坐标都相对于全局原点。

- **观察空间(View Space)**： 所有的坐标都是从摄像机的视角观察的。

- **裁剪空间(Clip Space)**： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪/透视除法）。

- **屏幕空间(Screen Space)**： 所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽/高。

- **LookAt矩阵**： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。

- **欧拉角(Euler Angles)**： 被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通过这三个值构造任何3D方向。

  

`glm::radians` 和 `glm::degrees` 都是 GLM 库中的数学函数，用于将角度转换为弧度和将弧度转换为角度。 具体来说，`glm::radians` 函数接受一个角度值（以度为单位），并返回相应的弧度值。例如，以下代码将角度值转换为弧度： 

```c++
float angle_degrees = 45.0f;
float angle_radians = glm::radians(angle_degrees);
```

 `glm::degrees` 函数则接受一个弧度值，并返回相应的角度值。例如，以下代码将弧度值转换为角度： 

```c++
float angle_radians = 0.7854f;
float angle_degrees = glm::degrees(angle_radians);
```



 因此，这两个函数的作用正好相反。一般来说，在使用 GLM 进行计算时，需要将所有的角度值都转换为弧度，然后再进行计算，最后将结果转换回角度供用户使用。



**如果你的渲染程序卡在打印日志处，很可能是因为 OpenGL 的错误消息队列中有大量的错误消息未被清除。在调用 OpenGL 函数时，如果产生了错误，则会将错误信息存储在 OpenGL 的错误消息队列中。**



**纹理渲染的步骤通常包括以下几个部分：**

1. 创建纹理对象。使用 `glGenTextures()` 函数生成纹理对象，并将其绑定到当前上下文中。
2. 加载纹理数据。可以使用 `glTexImage2D()` 函数从文件、内存等来源加载纹理图像数据，并将其上传至 GPU 中。在上传过程中，需要指定纹理的大小、格式、类型等参数。另外，也可以使用 FBO 和渲染缓冲区等方式生成纹理数据。
3. 设置纹理过滤方式。可以使用 `glTexParameteri()` 函数设置纹理的过滤方式，包括缩小过滤和放大过滤。常用的过滤方式包括线性过滤和最近邻过滤。
4. 设置纹理环绕方式。可以使用 `glTexParameteri()` 函数设置纹理的环绕方式。常见的环绕方式包括重复（Repeat）、镜像重复（Mirrored Repeat）和边缘拉伸（Clamp to Edge）等。
5. 绑定纹理到纹理单元。可以使用 `glActiveTexture()` 和 `glBindTexture()` 函数将纹理绑定到纹理单元上。通常情况下，可以使用 `GL_TEXTURE0` 等预定义的纹理单元进行绑定。
6. 在着色器中使用纹理。在着色器中，可以使用 `sampler2D` 类型的变量来表示 2D 纹理采样器。通过 `texture()` 函数对纹理进行采样操作，并将采样结果赋值给顶点或片元的颜色变量。
7. 渲染场景。在绘制场景时，需要将纹理绑定到相应的纹理单元上，并在着色器中使用纹理采样器进行纹理贴图操作。

以上是纹理渲染的基本步骤。通过合理设置纹理的参数和纹理单元，可以实现丰富多彩的纹理效果。